#!/usr/bin/env python

import re
import sys


def enum(**enums):
    return type('Enum', (), enums)

field_type = enum(
    s32    = 's32',
    u32    = 'u32',
    s64    = 's64',
    u64    = 'u64',
    string = 'string',
    vector = 'vector',
    custom = 'custom'
)

class ConfigDef:
    def __init__(self):
        self.name = None
        self.fields = []
        self.sub_def = []    # children definitions
        self.sup_def = None  # parent definition

    def __str__(self):
        return self.info(0)

    def info(self, indent):
        ret = '%sDEFINITION: %s\n%sfields:\n' % (' ' * indent, self.name, ' ' * indent)
        for f in self.fields:
            ret += f.info(indent + 4)

        for d in self.sub_def:
            ret += d.info(indent + 4)

        return ret

class FieldInfo:
    def __init__(self):
        self.field_type = None
        self.field_name = None
        # if the field is std::vector, sub_type is the type in vector
        # if the field is customized type, sub_type is that type
        self.sub_type   = None

    def __str__(self):
        return info(0)

    def info(self, indent):
        ret = '%stype: %s, name: %s' % (' ' * indent, self.field_type, self.field_name)
        if self.field_type in (field_type.vector, field_type.custom):
            assert self.sub_type
            ret += ', sub_type: %s' % (self.sub_type)
        ret += '\n'

        return ret

def build_config_def(root_lists, parent, name):
    _def = ConfigDef()
    _def.name = name
    if parent:
        _def.sup_def = parent
        parent.sub_def.append(_def)
    else:
        root_lists.append(_def)

    return _def

def build_field_info(line, type_str, name):
    field = FieldInfo()
    field.field_name = name

    if type_str == 'int' or type_str == 's32':
        field.field_type = field_type.s32
    elif type_str == 'u32':
        field.field_type = field_type.u32
    elif type_str == 's64':
        field.field_type = field_type.s64
    elif type_str == 'u64':
        field.field_type = field_type.u64
    elif type_str == 'std::string':
        field.field_type = field_type.string
    elif type_str.startswith('std::vector<'):
        field.field_type = field_type.vector
        ret = re.search('^std::vector< *([_a-zA-Z0-9]+) *>$', type_str)
        assert ret
        field.sub_type = ret.group(1)
    else:
        # customize types
        field.field_type = field_type.custom
        field.sub_type = type_str

    return field

def read_content(filename):
    content = None
    with open(filename, 'r') as f:
        content = f.read()

    content = content.replace('\r\n', '\n').replace('\t', '    ')

    # remove line comments // ... and block comments /* ... */
    content = re.sub('//.*\n', '\n', content)
    content = re.sub('/\*((?:.|\n)*?)\*/', '', content)

    # remove preprocessors
    content = re.sub('#ifndef.*\n', '\n', content)
    content = re.sub('#define.*\n', '\n', content)
    content = re.sub('#include.*\n', '\n', content)
    content = re.sub('#endif.*\n', '\n', content)

    # remove trailing whitespaces
    content = re.sub(' *\n', '\n', content)

    # make the brace after the definition, not the new line
    content = re.sub('\n *{', ' {\n', content)

    # remove extra empty lines
    content = re.sub('\n+', '\n', content)

    return content

def parse_content(content):
    def_list = []
    curr_def = None

    # split to lines, and remove empty ones
    lines = [x for x in content.split('\n') if x]

    for line in lines:
        line = line.strip()
        if not line: continue

        # the def start line
        ret = re.search('^DEF_CONFIG +([_a-zA-Z0-9]+) +{$', line)
        if ret:
            name = ret.group(1)
            _def = build_config_def(def_list, curr_def, name)
            curr_def = _def
            continue

        # the def end line
        ret = re.search('^ *};$', line)
        if ret:
            assert curr_def
            curr_def = curr_def.sup_def
            continue

        # the field line
        ret = re.search('^ *([_a-zA-Z0-9<>:]+) +([_a-zA-Z0-9]+);$', line)
        if ret:
            type_str = ret.group(1)
            name = ret.group(2)
            field = build_field_info(line, type_str, name)
            curr_def.fields.append(field)
            continue

        print "invalid line: %s" % (line)
        sys.exit(-1)

    return def_list

def write_source(def_list, filename):
    with open(filename, 'w') as f:
        f.write('// Generated by tool, DO NOT EDIT!!!\n\n')

        # TODO: add logic here


if __name__ == '__main__':
    argc = len(sys.argv)

    if argc != 3:
        print '============================================================'
        print 'Usage:'
        print '    python gen_source.py header_file output_source_file'
        print '============================================================'

        sys.exit(0)

    content = read_content(sys.argv[1])
    def_list = parse_content(content)
    write_source(def_list, argv[2])
